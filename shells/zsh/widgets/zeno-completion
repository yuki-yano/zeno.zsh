#autoload

emulate -L zsh

local callback callback_zero cmdline expect_key options source_command fzf_command tmux_opts_str
local -a out tmux_opts

# ${(f)...} : split by new-line (\n)
out=( "${(f)$(zeno-call-client-and-fallback --zeno-mode=completion \
  --input.lbuffer="$LBUFFER" \
  --input.rbuffer="$RBUFFER" \
  )}" )

if [[ $out[1] != success ]]; then
  zle ${ZENO_COMPLETION_FALLBACK:-${${functions[fzf-completion]+fzf-completion}:-expand-or-complete}}
  return
fi

source_command=$out[2]
options=$out[3]
callback=$out[4]
callback_zero=$out[5]

fzf_command=${ZENO_FZF_COMMAND:-fzf}
if [[ $fzf_command == fzf-tmux ]]; then
  if [[ -n ${TMUX-} ]] && (( $+commands[fzf-tmux] )); then
    if [[ -n ${ZENO_FZF_TMUX_OPTIONS-} ]]; then
      tmux_opts=(${(z)ZENO_FZF_TMUX_OPTIONS})
    fi
  else
    fzf_command=fzf
  fi
fi

if (( ${#tmux_opts[@]} > 0 )); then
  tmux_opts_str="${(j: :)tmux_opts} "
else
  tmux_opts_str=""
fi

options="${tmux_opts_str}${options}"
cmdline="${source_command} | ${fzf_command} ${options}"

# ${(0)...} : split by null (\0)
out=( "${(0)$(eval $cmdline)}" )

expect_key=$out[1]
shift out

# remove empty items
out=( ${(@)out:#} )

# filter output with callback
if [[ $callback && $out ]]; then
  if [[ $callback_zero ]]; then
    # divide input and output by null (\0)
    out=( "${(0)$(printf '%s\0' ${(@)out} | eval $callback)}" )
  else
    # divide input and output by new-line (\n)
    out=( "${(f)$(printf '%s\n' ${(@)out} | eval $callback)}" )
  fi

  # remove empty items
  out=( ${(@)out:#} )
fi

# update buffer if result is not empty
if [[ $out ]]; then
  # ${(@q)...} : quote each items
  LBUFFER+=${(@q)out}

  zle zeno-snippet-next-placeholder
fi

zle reset-prompt

#autoload

emulate -L zsh

local callback callback_kind callback_zero cmdline expect_key options source_command source_id fzf_command tmux_opts_str
local -a out tmux_opts expect_keys option_words

# ${(f)...} : split by new-line (\n)
out=( "${(f)$(zeno-call-client-and-fallback --zeno-mode=completion \
  --input.lbuffer="$LBUFFER" \
  --input.rbuffer="$RBUFFER" \
  )}" )

if [[ $out[1] != success ]]; then
  zle ${ZENO_COMPLETION_FALLBACK:-${${functions[fzf-completion]+fzf-completion}:-expand-or-complete}}
  return
fi

source_command=$out[2]
options=$out[3]
callback=$out[4]
callback_zero=$out[5]
callback_kind=$out[6]
source_id=$out[7]

if [[ -z $callback_kind ]]; then
  if [[ -n $callback ]]; then
    callback_kind=shell
  else
    callback_kind=none
  fi
fi

fzf_command=${ZENO_FZF_COMMAND:-fzf}
if [[ $fzf_command == fzf-tmux ]]; then
  if [[ -n ${TMUX-} ]] && (( $+commands[fzf-tmux] )); then
    if [[ -n ${ZENO_FZF_TMUX_OPTIONS-} ]]; then
      tmux_opts=(${(z)ZENO_FZF_TMUX_OPTIONS})
    fi
  else
    fzf_command=fzf
  fi
fi

if (( ${#tmux_opts[@]} > 0 )); then
  tmux_opts_str="${(j: :)tmux_opts} "
else
  tmux_opts_str=""
fi

options="${tmux_opts_str}${options}"
cmdline="${source_command} | ${fzf_command} ${options}"

# ${(0)...} : split by null (\0)
out=( "${(0)$(eval $cmdline)}" )

local option_word expect_value
option_words=(${(z)options})
for option_word in "${(@)option_words}"; do
  if [[ $option_word == --expect=* ]]; then
    expect_value=${option_word#--expect=}
    expect_keys=(${(s:,:)expect_value})
    break
  fi
done

expect_key=""
if (( ${#out[@]} > 0 )); then
  if (( ${#expect_keys[@]} > 0 )); then
    if (( ${expect_keys[(Ie)$out[1]]} > 0 )); then
      expect_key=$out[1]
      shift out
    fi
  elif [[ -z $out[1] ]]; then
    shift out
  fi
fi

# remove empty items
out=( ${(@)out:#} )

# filter output with shell callback
if [[ $callback_kind == shell && $callback && $out ]]; then
  if [[ $callback_zero ]]; then
    # divide input and output by null (\0)
    out=( "${(0)$(printf '%s\0' "${(@)out}" | eval $callback)}" )
  else
    # divide input and output by new-line (\n)
    out=( "${(f)$(printf '%s\n' "${(@)out}" | eval $callback)}" )
  fi

  # remove empty items
  out=( ${(@)out:#} )
elif [[ $callback_kind == function && $source_id && $out ]]; then
  local selected_file
  selected_file=$(mktemp 2>/dev/null || mktemp -t zeno-callback 2>/dev/null)

  if [[ -n $selected_file ]]; then
    chmod 600 "$selected_file" 2>/dev/null
    {
      printf '%s\0' "${(@)out}" >| "$selected_file"

      local -a callback_response callback_out
      callback_response=( "${(f)$(zeno-call-client-and-fallback --zeno-mode=completion-callback \
        --input.lbuffer="$LBUFFER" \
        --input.rbuffer="$RBUFFER" \
        --input.completionCallback.sourceId="$source_id" \
        --input.completionCallback.expectKey="$expect_key" \
        --input.completionCallback.selectedFile="$selected_file")}" )

      if [[ $callback_response[1] == success ]]; then
        if [[ -n $callback_response[2] ]]; then
          callback_out=( "${(0)$(eval $callback_response[2])}" )
        else
          callback_out=()
        fi

        callback_out=( ${(@)callback_out:#} )
        out=( "${(@)callback_out}" )
      fi
    } always {
      rm -f "$selected_file"
    }
  fi
fi

# update buffer if result is not empty
if [[ $out ]]; then
  # ${(@q)...} : quote each items
  LBUFFER+=${(@q)out}

  zle zeno-snippet-next-placeholder
fi

zle reset-prompt
